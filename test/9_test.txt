3 3 3
2 2 2
1 1 1

4 4 4
5 5 5
6 6 6

A+B = 7 7 7
      7 7 7
      7 7 7

A-B = -1 -1 -1
      -3 -3 -3
      -5 -5 -5

A*B = 45 45 45
      30 30 30
      15 15 15


0 -1 -2
-3 -4 -5
-6 -7 -8

15 18 21
24 27 30
33 36 39

A+B = 15 17 19
      21 23 25
      27 29 31

A-B = -15 -19 -23
      -27 -31 -35
      -39 -43 -47

A*B =  -90  -99 -108
      -306 -342 -378
      -522 -585 -648



%3dは少し短いかもしれません。かけ算をすると結構大きくなるし、マイナスがあると一文字余分に食うので。

確かにこれで3x3の行列はできていますが、これを10000x10000の行列に拡張してくださいと言われたら無理ですよね？
for文を使って書きましょう。何度も似たようなことを書くのはバグの元となります。

基本的にはOKなのですが、1000x1000とかの行列の積を計算するときにこれだと辛いですよね。
for文をもうちょっとだけ活用してかけ算をするにはどうすればいいですか？
これだと大きな行列（例えば100x100）とかになったときに応用できないですよね？

積の計算で
  t=s[1]+s[2]+s[3]
としているのはもったいないです。
これだと3x3より大きいサイズの行列への拡張ができなくなります。
せっかくfor文でs[k]を求めているので、t自体を加算していく方式で作ると良いです。
t = 0
for (k=1; k<=3; k++)
{
  t += a[i][k]*b[k][j];
}

それと、i, j, kを1からループさせてますが、これだとa[0][0]とかが使われないのでメモリがもったいないです。0〜2の範囲でループさせるために
for (k=0; k<3; k++)
とするのが一般的です。
